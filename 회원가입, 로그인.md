# 📚 3. 회원가입, 로그인

# 📚 1. 회원가입

**✔️ User**

```
User
- email
- password
- Authority authority(ROLE_USER, ROLE_ADMIN)
```

&nbsp;

**✔️ UserRestController**

```
UserRestController - signup
- userService.signup(userSignupRequestDto)
   - userSignupRequestDto에는 email, password만 들어가 있다.
```

&nbsp;


*`UserSignupRequestDto`*

```java
@Slf4j
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class UserSignupRequestDto {

		private String email;
    private String password;
    private int auth; // 0이라면 : admin, 1이라면 : user

}
```


&nbsp;

**✔️ UserService**

```java
		@Transactional
    public UserResponseDto signup(UserSignupRequestDto userSignupRequestDto){
        if(userRepository.existsByEmail(userSignupRequestDto.getEmail())){
            throw new RuntimeException("이미 가입되어 있는 유저입니다.");
        }

        // 회원가입시키기 위해 비밀번호를 암호로 바꿔서 저장한다.
        User user = userSignupRequestDto.toUser(passwordEncoder);
        return UserResponseDto.of(userRepository.save(user));
    }
```

```java
@Repository
public interface UserRepositoryextendsJpaRepository<User,Long> {

	//현재 가입된 email인지 확인
	boolean existsByEmail(Stringemail);
}
```

- 이미 가입된 유저인지 `email`을 통해 확인한다.
- `existByEmail` Repository


&nbsp;

```java
    User user = userSignupRequestDto.toUser(passwordEncoder);

		// userSignupRequestDto에 추가
    // PasswordEncoder를 이용하여 패스워드를 암호화하는 방법
    // ex) 'password' 라는 평문의 비밀번호를 $2a$10$kZ.aZODm7JAR7AHkuGlIr.6/6cAzZAN//kVrOy1aTsdkkP4kehoA.
    // 와 같은 암호로 바꿔서 서버에 저장하는 작업
		public User toUser(PasswordEncoder passwordEncoder){
        log.info("password : " + passwordEncoder);
        Authority authRes;
        if(auth == 1) authRes = Authority.ROLE_USER; // 사용자
        else authRes = Authority.ROLE_ADMIN; // 관리자

        return User.builder()
                .email(email)
                .password(passwordEncoder.encode(password)) // 입력된 비
                .authority(authRes)
                .build(); // 회원가입된 사용자
    }
```

- `passwordEncoder.encode(password)` : 'password' 라는 평문의 비밀번호를 $2a$10$kZ.aZODm7JAR7AHkuGlIr.6/6cAzZAN//kVrOy1aTsdkkP4kehoA. 와 같은 암호로 바꿔서 서버에 저장하는 작업

&nbsp;

<img width="884" alt="스크린샷 2022-12-24 오후 6 52 55" src="https://user-images.githubusercontent.com/72541544/209440118-3033a9bd-851d-4983-ab2f-f390b00602b1.png">


와 같이 저장된다.


&nbsp;

```java
return UserResponseDto.of(userRepository.save(user));
```

- save : JPA Repository의 메서드 구현


&nbsp;

`UserResponseDto`

```java
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class UserResponseDto {
    private String email;

    public static UserResponseDto of(User user){
        return new UserResponseDto(user.getEmail());
    }
}
```

- `email`을 `UserResponseDto`에 저장한다.
- 이메일을 클라이언트에게 전달

&nbsp;

&nbsp;

# 📚 2. 로그인

### 📖 A. Dto

**✔️ UserRequestDto**

```java
@Slf4j
@Getter
@AllArgsConstructor
@NoArgsConstructor
public class UserRequestDto {

    private String email;
    private String password;

}
```

&nbsp;

### 📖 B. Service(TokenService)

- **Spring Security Architecture**
    
   <img width="861" alt="스크린샷 2022-12-24 오후 6 00 18" src="https://user-images.githubusercontent.com/72541544/209440108-615a9976-c9c6-4a30-9a5d-e84627a59e8c.png">

    
    1. **사용자가 로그인 정보와 함께 인증 요청을 한다.(Http Request)**
    
    2.  **`AuthenticationFilter`가 요청을 가로채고, 가로챈 정보를 통해 `UsernamePasswordAuthenticationToken`의 인증용 객체를 생성한다.**
    
    3. **`AuthenticationManager`의 구현체인 `ProviderManager`에게 생성한 `UsernamePasswordToken` 객체를 전달한다.**
    
    4. **`AuthenticationManager`는 등록된 `AuthenticationProvider`(들)을 조회하여 인증을 요구한다.**
    
    5**. 실제 DB에서 사용자 인증정보를 가져오는 `UserDetailsService`에 사용자 정보를 넘겨준다.**
    
    6. **넘겨받은 사용자 정보를 통해 DB에서 찾은 사용자 정보인 `UserDetails` 객체를 만든다.**
    
    7. **`AuthenticationProvider`(들)은 `UserDetails`를 넘겨받고 사용자 정보를 비교한다.**
    
    8. **인증이 완료되면 권한 등의 사용자 정보를 담은 `Authentication` 객체를 반환한다.**
    
    9. **다시 최초의 `AuthenticationFilter`에 `Authentication` 객체가 반환된다.**
    
    10. **`Authentication` 객체를 `SecurityContext`에 저장한다.**
    
    ⇒ **최종적으로 `SecurityContextHolder`는 세션 영역에 있는 `SecurityContext`에 `Authentication` 객체를 저장한다.**
    
    ⇒ **사용자 정보를 저장한다는 것은 `Spring Security`가 전통적인 세션-쿠키 기반의 인증 방식을 사용한다는 것을 의미한다.**
    

&nbsp;

```java
		@Transactional
    public TokenDto login(UserRequestDto userRequestDto){

        // UsernamePasswordAuthenticationToken 형태로 리턴, SecurityContext 를 사용하기 위한 절차
        // 라이브러리에 있는 것 사용
        // 현재 입력된 아이디, 패스워드를 통해 token을 발급받는다.
        // UsernamePasswordAuthenticationToken
        // - 첫 번째 생성자는 인증 전의 객체를 생성하고
        // - 두 번째 생성자는 인증이 완료된 객체를 생성한다.
        UsernamePasswordAuthenticationToken authenticationToken = userRequestDto.authenticationToken();

        // 비밀번호 체크
        // authenticate 메서드가 실행이 될 때 CustomUserDetailsService 에서 만들었던 loadUserByUsername 메서드가 실행됨
        // loadUserByUsername
        // Authentication : 인증
        Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken);

        // 인증 정보를 통해 JWT 토큰을 생성한다.
        TokenDto tokenDto = jwtTokenProvider.generateTokenDto(authentication);

        // RefreshToken 저장
        RefreshToken refreshToken = RefreshToken.builder()
                .key(authentication.getName())
                .value(tokenDto.getRefreshToken())
                .build();

        refreshTokenRepository.save(refreshToken);

        // 토큰 발급
        return tokenDto;
    }
```

&nbsp;

**✔️ UsernamePasswordAuthenticationToken을 호출하다?**

```java
    // TokenService
		UsernamePasswordAuthenticationToken authenticationToken = userRequestDto.authenticationToken();

		// UserRequestDto
		public UsernamePasswordAuthenticationToken authenticationToken(){
        return new UsernamePasswordAuthenticationToken(email, password);
    }

```

- `UserRequestDto`에 구현된 `authenticationToken` 메서드를 호출한다.
- `UsernamePasswordAuthenticationToken` 의 생성자를 호출하는데?


&nbsp;

**✍🏻 UsernamePasswordAuthenticationToken을 뜯어보면**

```java
public abstract class AbstractAuthenticationToken implements Authentication, CredentialsContainer {
}
 
public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken {
 
	private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID;
 
	// 주로 사용자의 ID에 해당
	private final Object principal;
 
	// 주로 사용자의 PW에 해당
	private Object credentials;
 
	// 인증 완료 전의 객체 생성
	public UsernamePasswordAuthenticationToken(Object principal, Object credentials) {
		super(null);
		this.principal = principal;
		this.credentials = credentials;
		setAuthenticated(false);
	}
 
	// 인증 완료 후의 객체 생성
	public UsernamePasswordAuthenticationToken(Object principal, Object credentials,
			Collection<? extends GrantedAuthority> authorities) {
		super(authorities);
		this.principal = principal;
		this.credentials = credentials;
		super.setAuthenticated(true); // must use super, as we override
	}
}
```

- `첫 번째 principal` : 주로 사용자의 ID에 해당한다.
- `두 번째 credentials` : 주로 사용자의 PW에 해당한다.


&nbsp;

**✔️ Authentication, authenticationManagerBuilder을 호출하다?**

```java

private final AuthenticationManagerBuilder authenticationManagerBuilder;

Authentication authentication = authenticationManagerBuilder.getObject().authenticate(authenticationToken);
```

&nbsp;

**✍🏻 AuthenticationManagerBuilder을 뜯어보면**

```java
public class AuthenticationManagerBuilder
		extends AbstractConfiguredSecurityBuilder<AuthenticationManager, AuthenticationManagerBuilder>
		implements ProviderManagerBuilder<AuthenticationManagerBuilder> {

//...

}
```



- `AuthenticationManagerBuilder`에서 `AuthenticationManager` 를 구현한 `ProviderManager` 생성한다.


&nbsp;

**✍🏻 AuthenticationManager을 뜯어보면**

```java
public interface AuthenticationManager {
 
	Authentication authenticate(Authentication authentication) throws AuthenticationException;
 
}
```

- 인증에 대한 부분은 `AuthenticationManager` 를 통해서 처리하게 된다.
- 실질적으로는 `AuthenticationManager`에 등록된 `AuthenticationProvider`에 의해 처리된다.
- 인증에 성공하면 두번째 생성자를 이용해 객체를 생성하여 `SecurityContext`에 저장한다.(?)


&nbsp;

**✍🏻 AuthenticationProvider을 뜯어보면**

```java
public interface AuthenticationProvider {
 
	Authentication authenticate(Authentication authentication) throws AuthenticationException;
 
	boolean supports(Class<?> authentication);
 
}
```

- `AuthenticationProvider`에서는 실제 인증에 대한 부분을 처리한다.
- **인증 전의 `Authentication` 객체를 받아서 인증이 완료된 객체를 반환하는 역할을 한다.**
- 위와 같은 인터페이스를 구현해 `Custom`한 `AuthenticationProvider`를 작성하고 `AuthenticationManager`에 등록하면 된다.(?)

⇒ 결국, `authenticationManagerBuilder.getObject().authenticate(authenticationToken);` 를 통해 인증하고 결과를 반환한다.

⇒ `Authentication authentication` 에 저장된다.


&nbsp;

**✍🏻 Authentication을 뜯어보면**

```java
public interface Authentication extends Principal, Serializable {
	// 현재 사용자의 권한 목록을 가져옴
	Collection<? extends GrantedAuthority> getAuthorities();
    
	// credentials(주로 비밀번호)을 가져옴
	Object getCredentials();
    
	Object getDetails();
 
	// Principal 객체를 가져옴
	Object getPrincipal();
 
	// 인증 여부를 가져옴
	boolean isAuthenticated();
    
	// 인증 여부를 설정함
	void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;
 
}
```

- **현재 접근하는 주체의 정보와 권한을 담는 인터페이스이다.**
- `**Authentication` 객체는 `SecurityContext`에 저장된다.**
- `**SecurityContextHolder`를 통해 `SecurityContext`에 접근하고, `SecurityContext`를 통해 `Authentication`에 접근할 수 있다.**


&nbsp;

**✔️ JwtTokenProvider은 어떤 것일까?** 

```java
private final JwtTokenProvider jwtTokenProvider;

TokenDto tokenDto = jwtTokenProvider.generateTokenDto(authentication);
```


&nbsp;

**✍🏻 JwtTokenProvider을 뜯어보면**

```java
@Slf4j
@Component
public class JwtTokenProvider {

    // 이 클래스에서
    // - 유저 정보로 JWT 토큰을 만들거나 토큰을 바탕으로 유저 정보를 가져온다.
    // - JWT 토큰에 관련된 암호화, 복호화, 검증 로직은 다 이곳에서 이루어진다.

    // bean 직접 생성
    private static final String AUTHORITIES_KEY = "auth";
    private static final String BEARER_TYPE = "Bearer";
    private static final long ACCESS_TOKEN_EXPIRE_TIME = 1000 * 60 * 30;            // 30분
    private static final long REFRESH_TOKEN_EXPIRE_TIME = 1000 * 60 * 60 * 24 * 7;  // 7일

    private final Key key;

    // application.yml 에 정의해놓은 jwt.secret 값을 가져와서 JWT 를 만들 때 사용하는 암호화 키값을 생성
    public JwtTokenProvider(@Value("${spring.jwt.secret}") String secretKey){
        byte[] keyBytes = Decoders.BASE64.decode(secretKey);
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    // 유저 정보를 넘겨받아서 Access Token 과 Refresh Token을 생성
    public TokenDto generateTokenDto(Authentication authentication){
        // 권한들을 가져오기
        String authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));

        long now = (new Date()).getTime(); // 현재 시간

        // Access Token을 생성한다.
        Date accessTokenExpiresIn = new Date(now + ACCESS_TOKEN_EXPIRE_TIME);
        String accessToken = Jwts.builder()
                .setSubject(authentication.getName())       // payload "sub": "name"
                .claim(AUTHORITIES_KEY, authorities)        // payload "auth": "ROLE_USER"
                .setExpiration(accessTokenExpiresIn)        // payload "exp": 1516239022 (예시)
                .signWith(key, SignatureAlgorithm.HS512)    // header "alg": "HS512"
                .compact();

        // Refresh Token 생성
        String refreshToken = Jwts.builder()
                .setExpiration(new Date(now + REFRESH_TOKEN_EXPIRE_TIME))
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();

        return TokenDto.builder()
                .grantType(BEARER_TYPE)
                .accessToken(accessToken)
                .accessTokenExpiresIn(accessTokenExpiresIn.getTime()) // 만료시간
                .refreshToken(refreshToken)
                .build();
    }
}
```

- 생성자에서는 ?
    - `application.yml` 에 정의해놓은 `jwt.secret` 값을 가져와서 JWT 를 만들 때 사용하는 암호화 키값을 생성한다.
- `generateTokenDto`에서는 ? JWT 토큰에 관련된 **암호화**
    - 유저 정보를 넘겨받아서 **Access Token 과 Refresh Token 을 생성한다.**
    - 넘겨받은 유저 정보의 `authentication.getName()` 메소드가 `username` 을 가져온다.
    - `username` 으로 user ID 를 저장했기 때문에 해당 값이 설정된다.
    - Access Token 에는 유저와 권한 정보를 담고 Refresh Token 에는 아무 정보도 담지 않는다.


&nbsp;

**✍🏻 TokenDto는 어떤 것일까?**

```java
@Getter
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class TokenDto {

    private String grantType; // 고객
    private String accessToken;
    private String refreshToken;
    private Long accessTokenExpiresIn; // 액세스 토큰 만료기간
}
```

&nbsp;


**✔️ RefreshToken에 저장한다.**

```java
RefreshToken refreshToken = RefreshToken.builder()
                .key(authentication.getName())
                .value(tokenDto.getRefreshToken())
                .build();
```


&nbsp;

**✍🏻 RefreshToken은 무엇일까?**

```java
@Getter
@NoArgsConstructor
@Table(name = "refresh_token")
@Entity
public class RefreshToken {

    @Id
    @Column(name = "rt_key")
    private String key;

    @Column(name = "rt_value")
    private String value;

    @Builder
    public RefreshToken(String key, String value){
        this.key = key;
        this.value = value;
    }

    public RefreshToken updateValue(String token){
        this.value = token;
        return this;
    }
}
```

- `key`에는 사용자 `email`
- `value`에는 사용자 `refreshToken`


&nbsp;

**✔️ 끝으로 repository 호출 및 토큰 발급**

```java
refreshTokenRepository.save(refreshToken);

// 토큰 발급
return tokenDto;
```


&nbsp;

&nbsp;

# 📚 3. 토큰 재발급

### 📖 A. Dto

**✔️ TokenRequestDto**

```java
@Getter
@NoArgsConstructor
public class TokenRequestDto {
    private String accessToken;
    private String refreshToken;
}
```

&nbsp;


### 📖 B. Controller

```java
		@PostMapping("/reissue")
    public ResponseEntity<?> reissue(@RequestBody TokenRequestDto tokenRequestDto){
        return ResponseEntity.ok(userTokenRelatedService.reissue(tokenRequestDto));
    }
```

&nbsp;

### 📖 C. Service

```java
		@Transactional
    public TokenDto reissue(TokenRequestDto tokenRequestDto){
        // Refresh Token 검증
        if(!jwtTokenProvider.validateToken(tokenRequestDto.getRefreshToken())){
            throw new RuntimeException("Refresh Token이 유효하지 않습니다.");
        }

        // Access Token에서 User ID 가져오기
        Authentication authentication = jwtTokenProvider.getAuthentication(tokenRequestDto.getAccessToken());

        // 저장소에서 User ID를 기반으로 Refresh Token 값 가져오기
        RefreshToken refreshToken = refreshTokenRepository.findByKey(authentication.getName())
                .orElseThrow(() -> new RuntimeException("로그아웃 된 사용자입니다."));

        // Refresh Token 일치하는지 검사
        if(!refreshToken.getValue().equals(tokenRequestDto.getRefreshToken())){
            throw new RuntimeException("토큰의 유저 정보가 일치하지 않습니다.");
        }

        // 새로운 토큰 생성
        TokenDto tokenDto = jwtTokenProvider.generateTokenDto(authentication);

        // 저장소 정보 업데이트
        RefreshToken newRefreshToken = refreshToken.updateValue(tokenDto.getRefreshToken());
        refreshTokenRepository.save(newRefreshToken);

        // 토큰 발급
        return tokenDto;
    }
```


&nbsp;

**✔️ Refresh Token 검증**

```java
private final JwtTokenProvider jwtTokenProvider;		

// Refresh Token 검증
if(!jwtTokenProvider.validateToken(tokenRequestDto.getRefreshToken())){
		throw new RuntimeException("Refresh Token이 유효하지 않습니다.");
}
```

&nbsp;

**✍🏻 validateToken은 무엇이지?**

```java
		public boolean validateToken(String token){
        try{
            Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);
            return true;
        }catch (io.jsonwebtoken.security.SecurityException | MalformedJwtException e){
            log.info("잘못된 JWT 서명입니다.");
        }catch (ExpiredJwtException e){
            log.info("만료된 JWT 토큰입니다.");
        }catch (UnsupportedJwtException e){
            log.info("지원되지 않는 JWT 토큰입니다.");
        }catch (IllegalArgumentException e){
            log.info("JWT 토큰이 잘못되었습니다.");
        }
        return false;
    }
```

- **토큰을 검증하는 곳이다.**
- **`Jwts` 모듈이 알아서 Exception을 던져준다.**

&nbsp;


**✔️ Access Token에서 User ID 가져오기**

```java
Authentication authentication = jwtTokenProvider.getAuthentication(tokenRequestDto.getAccessToken());
```


&nbsp;


**✍🏻 getAuthentication는 무엇일까?**

```java
		public Authentication getAuthentication(String accessToken){
        // 토큰 복호화
        Claims claims = parseClaims(accessToken);

        if(claims.get(AUTHORITIES_KEY) == null){
            throw new RuntimeException("권한 정보가 없는 토큰입니다.");
        }

        // 클레임에서 권한 정보 가져오기
        Collection<? extends GrantedAuthority> authorities
                = Arrays.stream(claims.get(AUTHORITIES_KEY).toString().split(","))
                .map(SimpleGrantedAuthority::new)
                .collect(Collectors.toList());

        // UserDetails 객체를 만들어서 Authentication 리턴 (권한 인증 리턴)
        UserDetails userDetails = new org.springframework.security.core.userdetails.User(
                claims.getSubject()
                , ""
                , authorities
        );

        return new UsernamePasswordAuthenticationToken(userDetails, "",authorities);
    }

		private Claims parseClaims(String accessToken){
        try{
            return Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(accessToken).getBody();
        }catch(ExpiredJwtException e){
            return e.getClaims();
        }
    }
```

- JWT 토큰을 복호화하여 토큰에 들어 있는 정보를 꺼낸다.
- Access Token 에만 유저 정보를 담기 때문에 명시적으로 `accessToken` 을 파라미터로 받는다.
- Refresh Token 에는 아무런 정보 없이 만료일자만 담았다.
- `UserDetails` 객체를 생생성해서 `UsernamePasswordAuthenticationToken` 형태로 리턴하는데 `SecurityContext` 를 사용하기 위한 절차다.
- 사실 좀 불필요한 절차라고 생각되지만 `SecurityContext` 가 `Authentication` 객체를 저장하기 때문에 어쩔수 없다.
- **`parseClaims` 메소드는 만료된 토큰이어도 정보를 꺼내기 위해서 따로 분리했다.**


&nbsp;


**✍🏻 SimpleGrantedAuthority는 무엇일까?**

```java
package org.springframework.security.core.authority;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.SpringSecurityCoreVersion;
import org.springframework.util.Assert;

/**
 * Basic concrete implementation of a {@link GrantedAuthority}.
 *
 * <p>
 * Stores a {@code String} representation of an authority granted to the
 * {@link org.springframework.security.core.Authentication Authentication} object.
 *
 * @author Luke Taylor
 */
public final class SimpleGrantedAuthority implements GrantedAuthority {

	private static final long serialVersionUID = SpringSecurityCoreVersion.SERIAL_VERSION_UID;

	private final String role;

	public SimpleGrantedAuthority(String role) {
		Assert.hasText(role, "A granted authority textual representation is required");
		this.role = role;
	}

	@Override
	public String getAuthority() {
		return this.role;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj) {
			return true;
		}
		if (obj instanceof SimpleGrantedAuthority) {
			return this.role.equals(((SimpleGrantedAuthority) obj).role);
		}
		return false;
	}

	@Override
	public int hashCode() {
		return this.role.hashCode();
	}

	@Override
	public String toString() {
		return this.role;
	}

}
```

- https://www.apache.org/licenses/LICENSE-2.0
- `GrantedAuthority` : 현재 사용자가 가지고 있는 권한
- toString() : 역할 반환
- equals() : 현재 사용자 권한과 같은지 판단한다.


&nbsp;

**✔️ 저장소에서 User ID를 기반으로 Refresh Token 값 가져오기**

```java
RefreshToken refreshToken = refreshTokenRepository.findByKey(authentication.getName())
                .orElseThrow(() -> new RuntimeException("로그아웃 된 사용자입니다."));
```

- `findByKey`는 Repository에서 확인 가능하다.


&nbsp;

**✔️ Refresh Token 일치하는지 검사**

```java
if(!refreshToken.getValue().equals(tokenRequestDto.getRefreshToken())){
		throw new RuntimeException("토큰의 유저 정보가 일치하지 않습니다.");
}
```

&nbsp;


**✔️ 새로운 토큰 생성**

```java
TokenDto tokenDto = jwtTokenProvider.generateTokenDto(authentication);
```


&nbsp;

**✔️ 저장소 정보 업데이트(토큰 저장) 및 발급**

```java
// 저장소 정보 업데이트
RefreshToken newRefreshToken = refreshToken.updateValue(tokenDto.getRefreshToken());
refreshTokenRepository.save(newRefreshToken);

// 토큰 발급
return tokenDto;
```


&nbsp;

&nbsp;



----

**참고자료**

[Spring Security의 구조(Architecture) 및 처리 과정 알아보기](https://dev-coco.tistory.com/174)